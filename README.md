## Описание
Проект представляет собой связку вида клиент-сервер, обеспечивающую двухстороннюю синхронизацию текстового файла между сервером и ~~неограниченным числом~~ несколькими клиентами. На стороне сервера реализована система контроля версий, по аналогии с github, регистрирующая отдельные "коммиты" файла и позволяющая синхронизировать текст между сервером и клиентами, без передачи файла целиком. Подробности о том, как работает эта система, инструкции по развертыванию и техническое описание - в разделах ниже.
## Используемые технологии
#####  Клиентская часть:
Проект написан на Python 3. Для мониторинга событий файловой системы на стороне клиента используется библиотека **pyinotify**, для некоторых сравнительных операций, применяются библиотеки **difflib** и **filecmp**. Хэширование производится по алгоритму md5 с использованием библиотеки **hashlib**. Для связи с сервером используется **requests**.
#####  Серверная часть:
Сервер построен на микрофреймворке **flask**. В качестве базы данных используется **PostgreSQL**. Связь с бд реализуется через **psycopg2**. Серверная часть рассчитана на развертывание в связке из двух **docker**-контейнеров, через **docker-compose**.
## Как это работает?
В распоряжении клиентов и сервера, находятся текстовые файлы. При старте проекта, текстовые файлы клиентов и сервера идентичны. Клиент создает локальный бэкап файла. База данных, подключенная к серверу и исполняющая роль системы контроля версий так-же пуста (хэш сумма на диаграме носит условное обозначение, значения с одинаковыми числами - считать одинаковыми. ):

![](https://i.ibb.co/sg0vsyh/2023-01-30-09-16-34.png)

При изменении файла на одном из клиентов, происходит следующее: Клиент перехватывает сигнал файловой системы об изменении файла и вычленяет из него изменение, сравнивая бэкап с измененной версией. Клиент производит локальную валидацию изменений (допустимость значений, убеждается, что изменения произведены в конце файла, никакие данные не удалены). Если файл не проходит валидацию, клиент откатывает его до локального бэкапа. В противном случае, клиент запрашивает у сервера хэш сумму его текущего файла и сравнивает с хэш суммой своего **бекапа**. Если значения совпадают (клиент и сервер находятся на равных **энтри поинтах**), клиент передает изменение на сервер и обновляет свой бекап. Сервер в свою очередь, обновляет свою версию файла, а так-же **вносит изменение** в базу данных, записывая id, энтри поинт (хэш сумму, с которой можно обновиться до этого изменения), сам текст изменения, а так-же то, нужно ли присоединять этот текст к последней строке, или переносить на новую. На схеме ниже показан результат описанной ситуации - клиент 1 внес изменение в файл:

![](https://i.ibb.co/Qb81SqX/2023-01-30-09-45-21.png)

Как видно из диаграммы, хэш сумма сервера изменилась, а в базе данных появилась первая запись. Предположим, файл клиента 2 тоже был изменен. При сравнении хэш суммы бэкапа с сервером станет очевидно расхождение. В этом случае, клиент отправит свою хэш сумму (энтри поинт) серверу, который проверит, есть ли в базе данных изменения, которые можно применить с этого энтри поинта. В данном примере, они есть, т.к. клиент 2 отправил серверу (условную) хэш сумму 0. Сервер извлекает из базы данных параметры изменения и возвращает их клиенту. Клиент обновляет свой файл. После этого, происходит еще одно сравнение хэш суммы клиента 2 и сервера и т.к. обе стороны теперь имеют одинаковый энтри поинт (1), сделанные ранее изменения в файле клиента отправляются на сервер, о чем в базе данных делается соответствующая запись: 

![](https://i.ibb.co/SN27zNG/2023-01-30-09-56-12.png)

Теперь, при внесении изменений в файл клиента 3, будет произведено несколько обновлений файла, до тех пор, пока хэш сумма третьего клиента не будет равна хэш сумме сервера.

Таким образом, до тех пор, пока изменения в файлах, происходят во время работы клиентов, синхронизация данных между сервером и клиентами будет гарантирована непрерывностью логирования истории изменений. При этом, показатели потребления трафика будут оставаться на относительно низком уровне, т.к. для применения изменений используются отдельные инструкции, а не обновление файла целиком.

P.S. Если вы каким-то чудом дочитали до этого момента, приношу свои извенения за ужасное качество инфографики, шаблоны которой честно "позаимствованы" с venngage.com.
## Развертывание
Сервер разворачивается в дебаг режиме flask, в контейнере на localhost. Это намеренно сделано, с целью упрощения настройки демонстрационного стенда. Важно отметить, что проект не кросс-платформерный, сигналы об изменениях в файловой системе не будут перехватываться на Mac и Windows, соответственно клиент на этих платформах работать не будет.

1) Клонируем репозиторий: `git clone https://github.com/Raiksler/C2S_Sync.git`
2) Из директории C2S_Sync/server, разворачиваем образ docker-compose: `docker-compose build`
3) Поднимаем созданый компоуз командой: `docker-compose up -d`
4) Переходим в директорию C2S_Sync/client, оттуда устанавливаем зависимости командой: `poetry install` (понадобится пакет poetry, установить который, можно из пакетного менеджера)
5) Запускаем клиент командой: `poetry run python3 client.py`
6) Если все прошло гладко, консоль выведет сообщение об успешном подключении к серверу. С этого момента, можно пробовать обновлять файл data.txt и следить за результатом. Если потребуется больше клиентов, можно создать несколько копий директории client и повторить шаг 5. Я крайне рекомендую использовать стандартный текстовый редактор Ubuntu, т.к. тестирование производилось на нем.
## Known issues
Клиент рассинхронизируется при попытке подключиться к серверу с отредактированным при выключенном клиенте файлом. На данный момент, мне не удалось решить эту проблему, так-как в этом случае, клиент попробует подключиться к серверу с отличным от сервера и не зарегистрированным в базе хешем (энтри поинтом). Единственное (и не реализованное) решение, которое мне пришло в голову - полностью скачивать файл с сервера в таком случае, что противоречит идее системы. В общем, над этим предстоит поработать.
